"""
Trading Strategies for Lead-Lag Analysis

This module defines parameterized strategy classes that can be optimized.
Initial analysis shows that naive "trade on any event" doesn't work,
so we need more sophisticated filtering and entry/exit logic.

Key strategy families:
1. LatencyCapture: Trade on CL jumps, bet PM will follow
2. StrikeCross: Trade when CL crosses K, especially near expiry
3. FairValue: Trade on mispricing vs theoretical value (Phase 4)
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Literal
import pandas as pd
import numpy as np

try:
    from .execution_model import get_effective_prices
    from .event_detection import detect_cl_jumps, detect_strike_crosses
except ImportError:
    from execution_model import get_effective_prices
    from event_detection import detect_cl_jumps, detect_strike_crosses


@dataclass
class Signal:
    """A trading signal generated by a strategy."""
    market_id: str
    entry_t: int
    exit_t: int
    side: Literal['buy_up', 'sell_up', 'buy_down', 'sell_down']
    reason: str
    confidence: float = 1.0  # For position sizing
    metadata: Dict[str, Any] = field(default_factory=dict)


class Strategy(ABC):
    """Base class for trading strategies."""
    
    @property
    @abstractmethod
    def name(self) -> str:
        """Strategy name for logging."""
        pass
    
    @abstractmethod
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        """
        Generate trading signals for a single market.
        
        Args:
            market_df: DataFrame for single market
            
        Returns:
            List of Signal objects
        """
        pass
    
    def get_params(self) -> Dict[str, Any]:
        """Get strategy parameters for logging."""
        return {}


class LatencyCaptureStrategy(Strategy):
    """
    Trade after CL jumps, betting PM will follow.
    
    Parameters:
    - threshold_bps: Minimum CL move to trigger
    - hold_seconds: How long to hold
    - tau_min/max: Time-to-expiry filter
    - delta_min/max: Distance-to-strike filter
    - direction_filter: Only trade 'up', 'down', or 'both'
    """
    
    def __init__(
        self,
        threshold_bps: float = 10.0,
        hold_seconds: int = 15,
        tau_min: int = 0,
        tau_max: int = 900,
        delta_min_bps: float = 0,
        delta_max_bps: float = 10000,
        direction_filter: Literal['up', 'down', 'both'] = 'both'
    ):
        self.threshold_bps = threshold_bps
        self.hold_seconds = hold_seconds
        self.tau_min = tau_min
        self.tau_max = tau_max
        self.delta_min_bps = delta_min_bps
        self.delta_max_bps = delta_max_bps
        self.direction_filter = direction_filter
    
    @property
    def name(self) -> str:
        return f"LatencyCapture(thresh={self.threshold_bps}bps,hold={self.hold_seconds}s)"
    
    def get_params(self) -> Dict[str, Any]:
        return {
            'strategy': 'LatencyCapture',
            'threshold_bps': self.threshold_bps,
            'hold_seconds': self.hold_seconds,
            'tau_min': self.tau_min,
            'tau_max': self.tau_max,
            'delta_min_bps': self.delta_min_bps,
            'delta_max_bps': self.delta_max_bps,
            'direction_filter': self.direction_filter,
        }
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        signals = []
        market_id = market_df['market_id'].iloc[0]
        max_t = market_df['t'].max()
        
        # Detect CL jumps
        events = detect_cl_jumps(market_df, self.threshold_bps)
        
        for event in events:
            # Apply filters
            if not (self.tau_min <= event.tau <= self.tau_max):
                continue
            if not (self.delta_min_bps <= abs(event.delta_bps) <= self.delta_max_bps):
                continue
            if self.direction_filter != 'both' and event.direction != self.direction_filter:
                continue
            
            # Entry/exit times
            entry_t = event.t
            exit_t = min(entry_t + self.hold_seconds, max_t)
            
            # Trade direction
            side = 'buy_up' if event.direction == 'up' else 'buy_down'
            
            signals.append(Signal(
                market_id=market_id,
                entry_t=entry_t,
                exit_t=exit_t,
                side=side,
                reason=f'cl_jump_{event.magnitude_bps:.1f}bps_{event.direction}',
                metadata={
                    'event_type': 'cl_jump',
                    'magnitude_bps': event.magnitude_bps,
                    'tau': event.tau,
                    'delta_bps': event.delta_bps,
                }
            ))
        
        return signals


class StrikeCrossStrategy(Strategy):
    """
    Trade when CL crosses strike K.
    
    Most effective near expiry when probability should snap to 0/100.
    
    Parameters:
    - tau_max: Only trade when tau <= this (near expiry)
    - hold_to_expiry: If True, hold until market end
    - hold_seconds: If not hold_to_expiry, how long to hold
    - require_conviction: Only trade if CL moves further in same direction
    """
    
    def __init__(
        self,
        tau_max: int = 300,  # Only last 5 minutes
        hold_to_expiry: bool = True,
        hold_seconds: int = 60,
        min_follow_through_bps: float = 0  # CL must move this much more after cross
    ):
        self.tau_max = tau_max
        self.hold_to_expiry = hold_to_expiry
        self.hold_seconds = hold_seconds
        self.min_follow_through_bps = min_follow_through_bps
    
    @property
    def name(self) -> str:
        return f"StrikeCross(tau_max={self.tau_max}s)"
    
    def get_params(self) -> Dict[str, Any]:
        return {
            'strategy': 'StrikeCross',
            'tau_max': self.tau_max,
            'hold_to_expiry': self.hold_to_expiry,
            'hold_seconds': self.hold_seconds,
            'min_follow_through_bps': self.min_follow_through_bps,
        }
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        signals = []
        market_id = market_df['market_id'].iloc[0]
        max_t = market_df['t'].max()
        
        # Detect strike crosses
        events = detect_strike_crosses(market_df)
        
        for event in events:
            # Apply tau filter
            if event.tau > self.tau_max:
                continue
            
            entry_t = event.t
            
            # Exit time
            if self.hold_to_expiry:
                exit_t = max_t
            else:
                exit_t = min(entry_t + self.hold_seconds, max_t)
            
            # Trade direction (cross up = buy UP, cross down = buy DOWN)
            side = 'buy_up' if event.direction == 'up' else 'buy_down'
            
            signals.append(Signal(
                market_id=market_id,
                entry_t=entry_t,
                exit_t=exit_t,
                side=side,
                reason=f'strike_cross_{event.direction}_tau{event.tau}',
                metadata={
                    'event_type': 'strike_cross',
                    'tau': event.tau,
                    'delta_bps': event.delta_bps,
                }
            ))
        
        return signals


class MomentumStrategy(Strategy):
    """
    Trade on CL momentum (multiple consecutive moves in same direction).
    
    Parameters:
    - lookback: How many seconds to look back
    - min_total_move_bps: Minimum total move over lookback
    - min_consecutive: Minimum consecutive moves in same direction
    """
    
    def __init__(
        self,
        lookback: int = 5,
        min_total_move_bps: float = 15.0,
        min_consecutive: int = 3,
        hold_seconds: int = 15,
        tau_min: int = 0,
        tau_max: int = 900
    ):
        self.lookback = lookback
        self.min_total_move_bps = min_total_move_bps
        self.min_consecutive = min_consecutive
        self.hold_seconds = hold_seconds
        self.tau_min = tau_min
        self.tau_max = tau_max
    
    @property
    def name(self) -> str:
        return f"Momentum(lookback={self.lookback}s,thresh={self.min_total_move_bps}bps)"
    
    def get_params(self) -> Dict[str, Any]:
        return {
            'strategy': 'Momentum',
            'lookback': self.lookback,
            'min_total_move_bps': self.min_total_move_bps,
            'min_consecutive': self.min_consecutive,
            'hold_seconds': self.hold_seconds,
            'tau_min': self.tau_min,
            'tau_max': self.tau_max,
        }
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        signals = []
        market_id = market_df['market_id'].iloc[0]
        max_t = market_df['t'].max()
        
        df = market_df.copy().sort_values('t').reset_index(drop=True)
        
        # Calculate returns
        df['cl_return'] = df['cl_mid'].pct_change() * 10000  # bps
        df['return_sign'] = np.sign(df['cl_return'])
        
        # Rolling sum of returns and consecutive count
        df['rolling_return'] = df['cl_return'].rolling(self.lookback, min_periods=1).sum()
        
        # Count consecutive same-sign moves
        def count_consecutive(group):
            counts = []
            for i in range(len(group)):
                if i == 0:
                    counts.append(1)
                elif group.iloc[i] == group.iloc[i-1] and group.iloc[i] != 0:
                    counts.append(counts[-1] + 1)
                else:
                    counts.append(1)
            return counts
        
        df['consecutive'] = count_consecutive(df['return_sign'])
        
        # Generate signals where conditions are met
        already_signaled = set()  # Avoid overlapping signals
        
        for idx, row in df.iterrows():
            if pd.isna(row['rolling_return']):
                continue
            
            t = int(row['t'])
            tau = int(row['tau'])
            
            # Filters
            if not (self.tau_min <= tau <= self.tau_max):
                continue
            if abs(row['rolling_return']) < self.min_total_move_bps:
                continue
            if row['consecutive'] < self.min_consecutive:
                continue
            
            # Avoid overlapping
            if any(abs(t - s) < self.hold_seconds for s in already_signaled):
                continue
            
            already_signaled.add(t)
            
            entry_t = t
            exit_t = min(t + self.hold_seconds, max_t)
            direction = 'up' if row['rolling_return'] > 0 else 'down'
            side = 'buy_up' if direction == 'up' else 'buy_down'
            
            signals.append(Signal(
                market_id=market_id,
                entry_t=entry_t,
                exit_t=exit_t,
                side=side,
                reason=f'momentum_{direction}_{row["rolling_return"]:.1f}bps',
                metadata={
                    'rolling_return_bps': row['rolling_return'],
                    'consecutive': row['consecutive'],
                    'tau': tau,
                }
            ))
        
        return signals


class NearStrikeStrategy(Strategy):
    """
    Trade when CL is near strike AND moving.
    
    Near the strike, small CL moves should cause large PM moves.
    This combines the sensitivity insight with momentum.
    
    Parameters:
    - near_strike_bps: Definition of "near"
    - min_move_bps: Minimum CL move to trigger
    - hold_seconds: How long to hold
    """
    
    def __init__(
        self,
        near_strike_bps: float = 20.0,
        min_move_bps: float = 5.0,
        hold_seconds: int = 15,
        tau_max: int = 600  # Most effective in last 10 min
    ):
        self.near_strike_bps = near_strike_bps
        self.min_move_bps = min_move_bps
        self.hold_seconds = hold_seconds
        self.tau_max = tau_max
    
    @property
    def name(self) -> str:
        return f"NearStrike(within={self.near_strike_bps}bps)"
    
    def get_params(self) -> Dict[str, Any]:
        return {
            'strategy': 'NearStrike',
            'near_strike_bps': self.near_strike_bps,
            'min_move_bps': self.min_move_bps,
            'hold_seconds': self.hold_seconds,
            'tau_max': self.tau_max,
        }
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        signals = []
        market_id = market_df['market_id'].iloc[0]
        max_t = market_df['t'].max()
        
        df = market_df.copy().sort_values('t')
        df['cl_return_bps'] = df['cl_mid'].pct_change() * 10000
        
        already_signaled = set()
        
        for idx, row in df.iterrows():
            if pd.isna(row['cl_return_bps']):
                continue
            
            t = int(row['t'])
            tau = int(row['tau'])
            delta = abs(row['delta_bps'])
            
            # Must be near strike
            if delta > self.near_strike_bps:
                continue
            
            # Must be near expiry
            if tau > self.tau_max:
                continue
            
            # Must have significant move
            if abs(row['cl_return_bps']) < self.min_move_bps:
                continue
            
            # Avoid overlapping
            if any(abs(t - s) < self.hold_seconds for s in already_signaled):
                continue
            
            already_signaled.add(t)
            
            entry_t = t
            exit_t = min(t + self.hold_seconds, max_t)
            direction = 'up' if row['cl_return_bps'] > 0 else 'down'
            side = 'buy_up' if direction == 'up' else 'buy_down'
            
            signals.append(Signal(
                market_id=market_id,
                entry_t=entry_t,
                exit_t=exit_t,
                side=side,
                reason=f'near_strike_move_{direction}_{row["cl_return_bps"]:.1f}bps',
                metadata={
                    'delta_bps': row['delta_bps'],
                    'cl_move_bps': row['cl_return_bps'],
                    'tau': tau,
                }
            ))
        
        return signals


# ==============================================================================
# Control Strategies (for simulator validation)
# ==============================================================================

class DoNothingStrategy(Strategy):
    """
    Control strategy: 0 trades, 0 PnL.
    
    Purpose: Validate that simulator doesn't leak alpha when doing nothing.
    Expected: 0 trades, $0.00 PnL exactly.
    """
    
    @property
    def name(self) -> str:
        return "DoNothing"
    
    def get_params(self) -> Dict[str, Any]:
        return {'strategy': 'DoNothing'}
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        return []


class AlwaysTradeStrategy(Strategy):
    """
    Control strategy: Trade at regular intervals.
    
    Purpose: Validate spread cost is correctly applied.
    Expected: N trades, negative PnL approximately equal to N * avg_spread.
    
    Parameters:
    - interval_seconds: How often to trade
    - hold_seconds: How long to hold each trade
    - direction: 'up', 'down', or 'alternate'
    """
    
    def __init__(
        self,
        interval_seconds: int = 60,
        hold_seconds: int = 30,
        direction: Literal['up', 'down', 'alternate'] = 'up'
    ):
        self.interval_seconds = interval_seconds
        self.hold_seconds = hold_seconds
        self.direction = direction
    
    @property
    def name(self) -> str:
        return f"AlwaysTrade(interval={self.interval_seconds}s)"
    
    def get_params(self) -> Dict[str, Any]:
        return {
            'strategy': 'AlwaysTrade',
            'interval_seconds': self.interval_seconds,
            'hold_seconds': self.hold_seconds,
            'direction': self.direction,
        }
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        signals = []
        market_id = market_df['market_id'].iloc[0]
        max_t = market_df['t'].max()
        
        trade_count = 0
        for t in range(0, int(max_t) - self.hold_seconds, self.interval_seconds):
            # Determine direction
            if self.direction == 'alternate':
                side = 'buy_up' if trade_count % 2 == 0 else 'buy_down'
            elif self.direction == 'up':
                side = 'buy_up'
            else:
                side = 'buy_down'
            
            signals.append(Signal(
                market_id=market_id,
                entry_t=t,
                exit_t=t + self.hold_seconds,
                side=side,
                reason=f'always_trade_{trade_count}',
                metadata={'trade_number': trade_count}
            ))
            trade_count += 1
        
        return signals


class RandomSignalStrategy(Strategy):
    """
    Control strategy: Random entry/exit with random direction.
    
    Purpose: Validate no systematic bias in simulator.
    Expected: N trades, PnL approximately 0 with high variance.
    
    Parameters:
    - n_trades_per_market: How many random trades per market
    - hold_seconds: How long to hold each trade
    - seed: Random seed for reproducibility
    """
    
    def __init__(
        self,
        n_trades_per_market: int = 5,
        hold_seconds: int = 30,
        seed: int = 42
    ):
        self.n_trades_per_market = n_trades_per_market
        self.hold_seconds = hold_seconds
        self.seed = seed
    
    @property
    def name(self) -> str:
        return f"RandomSignal(n={self.n_trades_per_market},seed={self.seed})"
    
    def get_params(self) -> Dict[str, Any]:
        return {
            'strategy': 'RandomSignal',
            'n_trades_per_market': self.n_trades_per_market,
            'hold_seconds': self.hold_seconds,
            'seed': self.seed,
        }
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        signals = []
        market_id = market_df['market_id'].iloc[0]
        max_t = int(market_df['t'].max())
        
        # Create deterministic RNG based on market_id and seed
        market_seed = hash(market_id) % (2**31) + self.seed
        rng = np.random.RandomState(market_seed)
        
        # Generate random entry times
        valid_range = max_t - self.hold_seconds - 1
        if valid_range <= 0:
            return signals
        
        entry_times = rng.randint(0, valid_range, size=self.n_trades_per_market)
        directions = rng.choice(['buy_up', 'buy_down'], size=self.n_trades_per_market)
        
        for i, (t, side) in enumerate(zip(entry_times, directions)):
            signals.append(Signal(
                market_id=market_id,
                entry_t=int(t),
                exit_t=int(t + self.hold_seconds),
                side=side,
                reason=f'random_trade_{i}',
                metadata={'random_index': i}
            ))
        
        return signals


def run_control_validation(df: pd.DataFrame) -> Dict[str, Dict[str, Any]]:
    """
    Run all control strategies and validate results.
    
    Args:
        df: Full DataFrame with all markets
        
    Returns:
        Dict of control_name -> {metrics, expected, status}
    """
    try:
        from .backtest_engine import run_backtest, ExecutionConfig
    except ImportError:
        from backtest_engine import run_backtest, ExecutionConfig
    
    results = {}
    
    # DoNothing
    do_nothing = DoNothingStrategy()
    dn_result = run_backtest(df, do_nothing, ExecutionConfig())
    dn_pnl = dn_result['metrics']['total_pnl']
    dn_n = dn_result['metrics']['n_trades']
    results['DoNothing'] = {
        'metrics': dn_result['metrics'],
        'expected': '0 trades, $0.00 PnL',
        'status': 'PASS' if dn_n == 0 and dn_pnl == 0 else 'FAIL'
    }
    
    # AlwaysTrade
    always_trade = AlwaysTradeStrategy(interval_seconds=60, hold_seconds=30)
    at_result = run_backtest(df, always_trade, ExecutionConfig())
    at_pnl = at_result['metrics']['total_pnl']
    at_n = at_result['metrics']['n_trades']
    # Expected: negative PnL (paying spread)
    results['AlwaysTrade'] = {
        'metrics': at_result['metrics'],
        'expected': f'{at_n} trades, negative PnL',
        'status': 'PASS' if at_pnl < 0 else 'WARN (positive PnL unexpected)'
    }
    
    # RandomSignal
    random_signal = RandomSignalStrategy(n_trades_per_market=5, seed=42)
    rs_result = run_backtest(df, random_signal, ExecutionConfig())
    rs_pnl = rs_result['metrics']['total_pnl']
    rs_n = rs_result['metrics']['n_trades']
    # Expected: PnL close to 0 with variance
    avg_pnl = rs_pnl / rs_n if rs_n > 0 else 0
    results['RandomSignal'] = {
        'metrics': rs_result['metrics'],
        'expected': f'{rs_n} trades, ~$0 avg PnL',
        'status': 'PASS' if abs(avg_pnl) < 0.05 else 'WARN (avg PnL > $0.05)'
    }
    
    return results


class CompositeStrategy(Strategy):
    """
    Combine multiple strategies with optional filtering.
    
    Useful for A/B testing and ensemble approaches.
    """
    
    def __init__(
        self,
        strategies: List[Strategy],
        mode: Literal['any', 'all'] = 'any'
    ):
        self.strategies = strategies
        self.mode = mode
    
    @property
    def name(self) -> str:
        names = [s.name for s in self.strategies]
        return f"Composite({self.mode}:[{','.join(names)}])"
    
    def get_params(self) -> Dict[str, Any]:
        return {
            'strategy': 'Composite',
            'mode': self.mode,
            'sub_strategies': [s.get_params() for s in self.strategies],
        }
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        all_signals = []
        
        for strategy in self.strategies:
            signals = strategy.generate_signals(market_df)
            all_signals.extend(signals)
        
        if self.mode == 'all':
            # Only keep signals where all strategies agree
            # TODO: Implement consensus logic
            pass
        
        # Deduplicate by (entry_t, side)
        seen = set()
        unique_signals = []
        for sig in all_signals:
            key = (sig.entry_t, sig.side)
            if key not in seen:
                seen.add(key)
                unique_signals.append(sig)
        
        return unique_signals


# ==============================================================================
# Derived Strategies (from Profitable Trader Analysis)
# ==============================================================================

class UnderroundHarvesterStrategy(Strategy):
    """
    Strategy A: Underround Harvester (vidarx/Purple-inspired).
    
    Buy both sides when sum_asks < 1 - epsilon, hold to expiry for guaranteed profit.
    
    Parameters:
    - epsilon: Minimum underround threshold to trigger entry
    - min_tau: Minimum time to expiry (avoid last N seconds)
    - max_tau: Maximum time to expiry (entry window start)
    """
    
    def __init__(
        self,
        epsilon: float = 0.02,
        min_tau: int = 60,
        max_tau: int = 840,
    ):
        self.epsilon = epsilon
        self.min_tau = min_tau
        self.max_tau = max_tau
    
    @property
    def name(self) -> str:
        return f"UnderroundHarvester(eps={self.epsilon},tau={self.min_tau}-{self.max_tau})"
    
    def get_params(self) -> Dict[str, Any]:
        return {
            'strategy': 'UnderroundHarvester',
            'epsilon': self.epsilon,
            'min_tau': self.min_tau,
            'max_tau': self.max_tau,
        }
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        """
        Generate signals when sum_asks < 1 - epsilon.
        
        Note: This strategy buys BOTH sides, so we generate two signals per trigger.
        For backtesting purposes, we track them as buy_up signals with special metadata.
        """
        signals = []
        market_id = market_df['market_id'].iloc[0]
        max_t = market_df['t'].max()
        
        df = market_df.copy().sort_values('t')
        
        # Calculate sum of asks if not present
        if 'sum_asks' not in df.columns:
            if 'pm_up_best_ask' in df.columns and 'pm_down_best_ask' in df.columns:
                df['sum_asks'] = df['pm_up_best_ask'] + df['pm_down_best_ask']
            else:
                return signals
        
        already_triggered = set()
        cooldown = 30  # Seconds between triggers
        
        for idx, row in df.iterrows():
            t = int(row['t'])
            tau = int(row['tau'])
            sum_asks = row['sum_asks']
            
            # Skip if NaN or invalid
            if pd.isna(sum_asks):
                continue
            
            # Apply tau filter
            if not (self.min_tau <= tau <= self.max_tau):
                continue
            
            # Check underround condition
            underround = 1 - sum_asks
            if underround < self.epsilon:
                continue
            
            # Avoid overlapping triggers (cooldown)
            if any(abs(t - prev_t) < cooldown for prev_t in already_triggered):
                continue
            
            already_triggered.add(t)
            
            # Hold to expiry
            exit_t = int(max_t)
            
            # Signal to buy both sides (represented as buy_up with metadata)
            signals.append(Signal(
                market_id=market_id,
                entry_t=t,
                exit_t=exit_t,
                side='buy_up',  # For complete set, we track via buy_up
                reason=f'underround_{underround*100:.2f}pct',
                confidence=underround / self.epsilon,  # Higher confidence for larger underround
                metadata={
                    'strategy_type': 'complete_set',
                    'underround': underround,
                    'sum_asks': sum_asks,
                    'tau': tau,
                    'hold_to_expiry': True,
                }
            ))
        
        return signals


class LateDirectionalTakerStrategy(Strategy):
    """
    Strategy B: Late Directional Taker (tsaiTop-inspired).
    
    Take directional positions in last 5 minutes based on CL signal.
    
    Parameters:
    - tau_max: Only trade when tau <= tau_max (last N seconds)
    - delta_threshold_bps: Minimum |delta| in bps to trigger trade
    - hold_seconds: How long to hold position
    - momentum_window: Window for CL momentum calculation (seconds)
    """
    
    def __init__(
        self,
        tau_max: int = 300,
        delta_threshold_bps: float = 10.0,
        hold_seconds: int = 180,
        momentum_window: int = 10,
    ):
        self.tau_max = tau_max
        self.delta_threshold_bps = delta_threshold_bps
        self.hold_seconds = hold_seconds
        self.momentum_window = momentum_window
    
    @property
    def name(self) -> str:
        return f"LateDirectional(tau<{self.tau_max},delta>{self.delta_threshold_bps}bps)"
    
    def get_params(self) -> Dict[str, Any]:
        return {
            'strategy': 'LateDirectionalTaker',
            'tau_max': self.tau_max,
            'delta_threshold_bps': self.delta_threshold_bps,
            'hold_seconds': self.hold_seconds,
            'momentum_window': self.momentum_window,
        }
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        signals = []
        market_id = market_df['market_id'].iloc[0]
        max_t = int(market_df['t'].max())
        
        df = market_df.copy().sort_values('t').reset_index(drop=True)
        
        # Calculate momentum (rolling return over window)
        df['cl_return_bps'] = df['cl_mid'].pct_change() * 10000
        df['momentum'] = df['cl_return_bps'].rolling(self.momentum_window, min_periods=1).sum()
        
        already_signaled = set()
        
        for idx, row in df.iterrows():
            t = int(row['t'])
            tau = int(row['tau'])
            
            # Only trade in late window
            if tau > self.tau_max:
                continue
            
            # Check delta threshold
            delta_bps = row.get('delta_bps', 0)
            if pd.isna(delta_bps) or abs(delta_bps) < self.delta_threshold_bps:
                continue
            
            # Check momentum confirms direction
            momentum = row.get('momentum', 0)
            if pd.isna(momentum):
                continue
            
            # Direction from delta sign (above strike = likely UP, below = likely DOWN)
            direction = 'up' if delta_bps > 0 else 'down'
            
            # Momentum should confirm
            if (direction == 'up' and momentum < 0) or (direction == 'down' and momentum > 0):
                continue
            
            # Avoid overlapping signals
            if any(abs(t - s) < self.hold_seconds for s in already_signaled):
                continue
            
            already_signaled.add(t)
            
            entry_t = t
            exit_t = min(t + self.hold_seconds, max_t)
            side = 'buy_up' if direction == 'up' else 'buy_down'
            
            signals.append(Signal(
                market_id=market_id,
                entry_t=entry_t,
                exit_t=exit_t,
                side=side,
                reason=f'late_directional_{direction}_delta{abs(delta_bps):.0f}bps',
                metadata={
                    'delta_bps': delta_bps,
                    'momentum': momentum,
                    'tau': tau,
                }
            ))
        
        return signals


class TwoSidedEarlyTiltLateStrategy(Strategy):
    """
    Strategy C: Two-Sided Early, Tilt Late (Purple/Account-inspired).
    
    Phase 1: Build matched inventory early (buy both sides when underround)
    Phase 2: Add net exposure late based on CL sign/strike-cross
    
    Parameters:
    - inventory_phase_end: Stop building inventory when tau drops below this (seconds)
    - tilt_phase_start: Start adding net exposure when tau drops below this (seconds)
    - inventory_epsilon: Underround threshold for inventory building
    - tilt_delta_threshold_bps: Minimum |delta| in bps to tilt
    """
    
    def __init__(
        self,
        inventory_phase_end: int = 300,
        tilt_phase_start: int = 180,
        inventory_epsilon: float = 0.02,
        tilt_delta_threshold_bps: float = 15.0,
    ):
        self.inventory_phase_end = inventory_phase_end
        self.tilt_phase_start = tilt_phase_start
        self.inventory_epsilon = inventory_epsilon
        self.tilt_delta_threshold_bps = tilt_delta_threshold_bps
    
    @property
    def name(self) -> str:
        return f"TwoSidedTilt(inv<{self.inventory_phase_end},tilt<{self.tilt_phase_start})"
    
    def get_params(self) -> Dict[str, Any]:
        return {
            'strategy': 'TwoSidedEarlyTiltLate',
            'inventory_phase_end': self.inventory_phase_end,
            'tilt_phase_start': self.tilt_phase_start,
            'inventory_epsilon': self.inventory_epsilon,
            'tilt_delta_threshold_bps': self.tilt_delta_threshold_bps,
        }
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        signals = []
        market_id = market_df['market_id'].iloc[0]
        max_t = int(market_df['t'].max())
        
        df = market_df.copy().sort_values('t')
        
        # Calculate sum of asks if not present
        if 'sum_asks' not in df.columns:
            if 'pm_up_best_ask' in df.columns and 'pm_down_best_ask' in df.columns:
                df['sum_asks'] = df['pm_up_best_ask'] + df['pm_down_best_ask']
        
        inventory_triggered = set()
        tilt_triggered = set()
        cooldown = 30
        
        for idx, row in df.iterrows():
            t = int(row['t'])
            tau = int(row['tau'])
            
            # Phase 1: Inventory building (early)
            if tau > self.inventory_phase_end:
                sum_asks = row.get('sum_asks', None)
                if sum_asks is not None and not pd.isna(sum_asks):
                    underround = 1 - sum_asks
                    if underround >= self.inventory_epsilon:
                        if not any(abs(t - prev) < cooldown for prev in inventory_triggered):
                            inventory_triggered.add(t)
                            signals.append(Signal(
                                market_id=market_id,
                                entry_t=t,
                                exit_t=max_t,  # Hold to expiry
                                side='buy_up',  # Complete set represented as buy_up
                                reason=f'inventory_build_{underround*100:.2f}pct',
                                metadata={
                                    'phase': 'inventory',
                                    'strategy_type': 'complete_set',
                                    'underround': underround,
                                    'tau': tau,
                                }
                            ))
            
            # Phase 2: Tilt (late)
            elif tau <= self.tilt_phase_start:
                delta_bps = row.get('delta_bps', 0)
                if not pd.isna(delta_bps) and abs(delta_bps) >= self.tilt_delta_threshold_bps:
                    if not any(abs(t - prev) < cooldown for prev in tilt_triggered):
                        tilt_triggered.add(t)
                        direction = 'up' if delta_bps > 0 else 'down'
                        side = 'buy_up' if direction == 'up' else 'buy_down'
                        
                        signals.append(Signal(
                            market_id=market_id,
                            entry_t=t,
                            exit_t=max_t,  # Hold to expiry
                            side=side,
                            reason=f'tilt_{direction}_delta{abs(delta_bps):.0f}bps',
                            metadata={
                                'phase': 'tilt',
                                'delta_bps': delta_bps,
                                'tau': tau,
                            }
                        ))
        
        return signals


# ==============================================================================
# MISPRICING-BASED STRATEGY (Fair Value Model Approach)
# ==============================================================================

class MispricingBasedStrategy(Strategy):
    """
    Mispricing-based late directional strategy.
    
    Instead of "delta >= 10bps -> bet direction", this strategy:
    1. Estimates fair probability p_hat = f(delta_bps, tau, realized_vol)
    2. Trades only when PM's implied p deviates from p_hat by > (spread + buffer)
    
    This reduces regime dependence by betting on mispricing vs a stable model,
    not on raw directional signals.
    
    Parameters:
    - fair_value_model: Fitted BinnedFairValueModel or FairValueModel
    - buffer: Minimum mispricing to trigger trade (default 0.02 = 2 cents)
    - tau_max: Only trade when tau <= tau_max (last N seconds)
    - min_tau: Avoid trading in last N seconds (optional)
    - cooldown: Minimum seconds between signals
    - exit_rule: 'expiry' (hold to expiry) or 'convergence' (exit when mispricing collapses)
    - exit_buffer: For convergence exit, exit when mispricing < exit_buffer
    - max_hold_seconds: For convergence exit, max holding time
    """
    
    def __init__(
        self,
        fair_value_model=None,
        buffer: float = 0.02,
        tau_max: int = 420,
        min_tau: int = 0,
        cooldown: int = 30,
        exit_rule: str = 'expiry',
        exit_buffer: float = 0.01,
        max_hold_seconds: int = 180,
    ):
        """
        Initialize mispricing strategy.
        
        Args:
            fair_value_model: Fitted model with predict() method
            buffer: Minimum mispricing to trade (default 0.02)
            tau_max: Only trade in last N seconds (default 420 = 7 min)
            min_tau: Avoid last N seconds (default 0)
            cooldown: Seconds between signals (default 30)
            exit_rule: 'expiry' or 'convergence'
            exit_buffer: For convergence, exit when mispricing < this
            max_hold_seconds: For convergence, max holding time
        """
        self.fair_value_model = fair_value_model
        self.buffer = buffer
        self.tau_max = tau_max
        self.min_tau = min_tau
        self.cooldown = cooldown
        self.exit_rule = exit_rule
        self.exit_buffer = exit_buffer
        self.max_hold_seconds = max_hold_seconds
    
    @property
    def name(self) -> str:
        return f"MispricingBased(buf={self.buffer:.2f},tau<{self.tau_max})"
    
    def get_params(self) -> Dict[str, Any]:
        return {
            'strategy': 'MispricingBased',
            'buffer': self.buffer,
            'tau_max': self.tau_max,
            'min_tau': self.min_tau,
            'cooldown': self.cooldown,
            'exit_rule': self.exit_rule,
            'exit_buffer': self.exit_buffer,
            'max_hold_seconds': self.max_hold_seconds,
        }
    
    def set_model(self, model):
        """Set the fair value model (for external fitting)."""
        self.fair_value_model = model
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        """
        Generate signals based on mispricing.
        
        Entry logic:
        - Buy UP if: p_hat_up - buy_up_price > buffer AND min_tau < tau < tau_max
        - Buy DOWN if: p_hat_down - buy_down_price > buffer AND min_tau < tau < tau_max
        - If both trigger: pick larger mispricing
        
        Exit logic:
        - Expiry: hold to market end
        - Convergence: exit when mispricing < exit_buffer or after max_hold_seconds
        """
        signals = []
        
        if self.fair_value_model is None:
            return signals
        
        market_id = market_df['market_id'].iloc[0]
        max_t = int(market_df['t'].max())
        
        df = market_df.copy().sort_values('t').reset_index(drop=True)
        
        # Get fair value predictions for all rows
        try:
            p_hat = self.fair_value_model.predict(df)
        except Exception:
            # Model might not be fitted or compatible
            return signals
        
        df['p_hat_up'] = p_hat
        df['p_hat_down'] = 1 - p_hat
        
        # Compute effective prices using conversion routing
        # Buy UP = min(up_ask, 1 - down_bid)
        # Buy DOWN = min(down_ask, 1 - up_bid)
        df['buy_up_price'] = np.minimum(
            df['pm_up_best_ask'],
            1 - df['pm_down_best_bid']
        )
        df['buy_down_price'] = np.minimum(
            df['pm_down_best_ask'],
            1 - df['pm_up_best_bid']
        )
        
        # Sell UP = max(up_bid, 1 - down_ask)
        # Sell DOWN = max(down_bid, 1 - up_ask)
        df['sell_up_price'] = np.maximum(
            df['pm_up_best_bid'],
            1 - df['pm_down_best_ask']
        )
        df['sell_down_price'] = np.maximum(
            df['pm_down_best_bid'],
            1 - df['pm_up_best_ask']
        )
        
        # Mispricing = fair value - market price (positive = underpriced, good to buy)
        df['mispricing_up'] = df['p_hat_up'] - df['buy_up_price']
        df['mispricing_down'] = df['p_hat_down'] - df['buy_down_price']
        
        already_signaled = set()
        
        for idx, row in df.iterrows():
            t = int(row['t'])
            tau = int(row['tau'])
            
            # Time filters
            if tau > self.tau_max or tau < self.min_tau:
                continue
            
            # Check for valid prices
            if pd.isna(row['buy_up_price']) or pd.isna(row['buy_down_price']):
                continue
            if pd.isna(row['p_hat_up']) or pd.isna(row['p_hat_down']):
                continue
            
            # Get mispricing values
            mispricing_up = row['mispricing_up']
            mispricing_down = row['mispricing_down']
            
            # Check if either side has sufficient mispricing
            up_signal = mispricing_up > self.buffer
            down_signal = mispricing_down > self.buffer
            
            if not up_signal and not down_signal:
                continue
            
            # Cooldown check
            if any(abs(t - s) < self.cooldown for s in already_signaled):
                continue
            
            already_signaled.add(t)
            
            # Choose direction with larger mispricing
            if up_signal and down_signal:
                if mispricing_up >= mispricing_down:
                    side = 'buy_up'
                    mispricing = mispricing_up
                    entry_price = row['buy_up_price']
                else:
                    side = 'buy_down'
                    mispricing = mispricing_down
                    entry_price = row['buy_down_price']
            elif up_signal:
                side = 'buy_up'
                mispricing = mispricing_up
                entry_price = row['buy_up_price']
            else:
                side = 'buy_down'
                mispricing = mispricing_down
                entry_price = row['buy_down_price']
            
            # Determine exit time
            if self.exit_rule == 'expiry':
                exit_t = max_t
            else:  # convergence
                exit_t = self._find_convergence_exit(
                    df, t, side, row['p_hat_up'] if side == 'buy_up' else row['p_hat_down'], max_t
                )
            
            signals.append(Signal(
                market_id=market_id,
                entry_t=t,
                exit_t=exit_t,
                side=side,
                reason=f'mispricing_{side.split("_")[1]}_{mispricing:.3f}',
                confidence=mispricing / self.buffer,  # Higher confidence for larger mispricing
                metadata={
                    'p_hat': row['p_hat_up'] if side == 'buy_up' else row['p_hat_down'],
                    'entry_price': entry_price,
                    'mispricing': mispricing,
                    'tau': tau,
                    'exit_rule': self.exit_rule,
                }
            ))
        
        return signals
    
    def _find_convergence_exit(
        self, 
        df: pd.DataFrame, 
        entry_t: int, 
        side: str,
        p_hat_at_entry: float,
        max_t: int
    ) -> int:
        """
        Find exit time using convergence rule.
        
        Exit when:
        - Mispricing collapses (sell_price >= p_hat - exit_buffer)
        - Or max_hold_seconds reached
        - Or market ends
        """
        exit_t = min(entry_t + self.max_hold_seconds, max_t)
        
        # Look for early exit opportunity
        future_rows = df[(df['t'] > entry_t) & (df['t'] <= exit_t)]
        
        for _, row in future_rows.iterrows():
            t = int(row['t'])
            
            if side == 'buy_up':
                sell_price = row['sell_up_price']
                # Exit if we can sell close to fair value
                if not pd.isna(sell_price) and sell_price >= p_hat_at_entry - self.exit_buffer:
                    return t
            else:  # buy_down
                sell_price = row['sell_down_price']
                if not pd.isna(sell_price) and sell_price >= p_hat_at_entry - self.exit_buffer:
                    return t
        
        return exit_t


# ==============================================================================
# SPREAD CAPTURE STRATEGY (Maker / Market-Making Style)
# ==============================================================================

class SpreadCaptureStrategy(Strategy):
    """
    Two-sided market making / spread capture strategy (Variant B).
    
    This strategy attempts to capture the bid-ask spread by placing passive
    quotes on both sides of the market. It is fundamentally different from
    the directional strategies above - it profits from spread, not direction.
    
    Key idea: Place limit orders at best bid and best ask, capture spread
    when both legs fill, manage inventory risk.
    
    This strategy generates "quote intentions" rather than traditional signals.
    The actual execution is handled by the FillEngine in maker_execution.py.
    
    Parameters:
    - spread_min: Minimum spread to quote (below this, not worth it)
    - tau_min: Don't quote when tau < this (too close to expiry, chaos)
    - tau_max: Don't quote when tau > this (early market, low activity)
    - inventory_limit_up: Max UP inventory (stop quoting when hit)
    - inventory_limit_down: Max DOWN inventory
    - tau_flatten: Flatten all positions when tau <= this
    - quote_improvement_ticks: Improve by N ticks (0 = join best)
    - adverse_selection_filter: Skip quoting after big CL jumps
    - cl_jump_threshold_bps: CL move threshold for adverse selection filter
    - max_quote_update_rate: Skip if quote changes too fast
    
    NOTE: This strategy is designed to be used with the FillEngine,
    not the standard backtest_engine execute_signal function.
    """
    
    def __init__(
        self,
        spread_min: float = 0.02,  # Minimum spread to quote (2Â¢)
        tau_min: int = 120,  # Don't quote when tau < this (avoid end chaos)
        tau_max: int = 600,  # Don't quote when tau > this (early market)
        inventory_limit_up: float = 10.0,  # Max UP inventory
        inventory_limit_down: float = 10.0,  # Max DOWN inventory
        tau_flatten: int = 60,  # Flatten all positions when tau <= this
        quote_improvement_ticks: int = 0,  # Improve by N ticks (0 = join best)
        adverse_selection_filter: bool = True,  # Skip quoting after big CL jumps
        cl_jump_threshold_bps: float = 10.0,  # CL move threshold for AS filter
        cl_lookback_seconds: int = 5,  # Lookback for CL jump detection
        max_quote_update_rate: float = 0.5,  # Skip if quote changes >50%/sec
        quote_size: float = 1.0,  # Size per quote
        two_sided: bool = True,  # Quote both sides (True) or one side
        token: str = 'UP',  # If one-sided, which token ('UP' or 'DOWN')
        # Inventory skew parameters (one-sided mode when imbalanced)
        inventory_skew_enabled: bool = True,  # Enable inventory skew
        skew_threshold_up: float = 5.0,  # When UP inventory > this, only quote ask
        skew_threshold_down: float = 5.0,  # When DOWN inventory > this, only quote ask
        # Net edge threshold (replaces spread_min with expected edge calculation)
        use_net_edge_threshold: bool = False,  # Use expected edge instead of spread_min
        edge_threshold: float = 0.0,  # Minimum expected net edge to quote
        edge_buffer: float = 0.005,  # Safety buffer (0.5 cents)
        expected_as_per_spread: float = 0.5,  # E[AS] = this fraction of spread
        # Depth-based filters (requires 6-level data)
        imbalance_filter_enabled: bool = False,  # Filter based on order book imbalance
        imbalance_threshold: float = 0.3,  # |imbalance| < this to quote both sides
        imbalance_levels: int = 3,  # How many levels to use for imbalance (1-6)
        min_top6_depth: float = 0.0,  # Minimum total depth across 6 levels to quote
        quote_level: int = 1,  # Which level to quote at (1=best, 2=second best, etc.)
    ):
        self.spread_min = spread_min
        self.tau_min = tau_min
        self.tau_max = tau_max
        self.inventory_limit_up = inventory_limit_up
        self.inventory_limit_down = inventory_limit_down
        self.tau_flatten = tau_flatten
        self.quote_improvement_ticks = quote_improvement_ticks
        self.adverse_selection_filter = adverse_selection_filter
        self.cl_jump_threshold_bps = cl_jump_threshold_bps
        self.cl_lookback_seconds = cl_lookback_seconds
        self.max_quote_update_rate = max_quote_update_rate
        self.quote_size = quote_size
        self.two_sided = two_sided
        self.token = token
        self.inventory_skew_enabled = inventory_skew_enabled
        self.skew_threshold_up = skew_threshold_up
        self.skew_threshold_down = skew_threshold_down
        self.use_net_edge_threshold = use_net_edge_threshold
        self.edge_threshold = edge_threshold
        self.edge_buffer = edge_buffer
        self.expected_as_per_spread = expected_as_per_spread
        self.imbalance_filter_enabled = imbalance_filter_enabled
        self.imbalance_threshold = imbalance_threshold
        self.imbalance_levels = imbalance_levels
        self.min_top6_depth = min_top6_depth
        self.quote_level = quote_level
    
    @property
    def name(self) -> str:
        side_str = "2sided" if self.two_sided else f"1sided_{self.token}"
        skew_str = "+skew" if self.inventory_skew_enabled else ""
        return f"SpreadCapture({side_str}{skew_str},spread>{self.spread_min:.2f},tau[{self.tau_min},{self.tau_max}])"
    
    def get_params(self) -> Dict[str, Any]:
        return {
            'strategy': 'SpreadCapture',
            'spread_min': self.spread_min,
            'tau_min': self.tau_min,
            'tau_max': self.tau_max,
            'inventory_limit_up': self.inventory_limit_up,
            'inventory_limit_down': self.inventory_limit_down,
            'tau_flatten': self.tau_flatten,
            'quote_improvement_ticks': self.quote_improvement_ticks,
            'adverse_selection_filter': self.adverse_selection_filter,
            'cl_jump_threshold_bps': self.cl_jump_threshold_bps,
            'quote_size': self.quote_size,
            'two_sided': self.two_sided,
            'token': self.token,
            'inventory_skew_enabled': self.inventory_skew_enabled,
            'skew_threshold_up': self.skew_threshold_up,
            'skew_threshold_down': self.skew_threshold_down,
            'use_net_edge_threshold': self.use_net_edge_threshold,
            'edge_threshold': self.edge_threshold,
            'edge_buffer': self.edge_buffer,
            'expected_as_per_spread': self.expected_as_per_spread,
            'imbalance_filter_enabled': self.imbalance_filter_enabled,
            'imbalance_threshold': self.imbalance_threshold,
            'imbalance_levels': self.imbalance_levels,
            'min_top6_depth': self.min_top6_depth,
            'quote_level': self.quote_level,
        }
    
    def generate_signals(self, market_df: pd.DataFrame) -> List[Signal]:
        """
        Generate quote intentions for maker strategy.
        
        NOTE: For spread capture, we don't generate traditional "signals" with
        entry_t and exit_t. Instead, we generate quote intentions that indicate
        when and where we want to place passive orders.
        
        The actual order management is handled by run_maker_backtest() which
        uses the FillEngine to simulate fills.
        
        This method is provided for compatibility with the Strategy interface
        but returns empty list - use should_quote() instead.
        """
        # For spread capture, we use the should_quote() interface instead
        # This is called tick-by-tick by the maker backtest engine
        return []
    
    def should_quote(
        self,
        row: pd.Series,
        inventory_up: float = 0.0,
        inventory_down: float = 0.0,
        prev_rows: Optional[pd.DataFrame] = None,
    ) -> Dict[str, Any]:
        """
        Determine if we should place/maintain quotes at current tick.
        
        This is the main decision function called by run_maker_backtest().
        
        Args:
            row: Current market data row
            inventory_up: Current UP position
            inventory_down: Current DOWN position
            prev_rows: Previous N rows for CL jump detection
            
        Returns:
            Dictionary with:
            - quote_up_bid: Price to bid for UP (None = don't quote)
            - quote_up_ask: Price to ask for UP (None = don't quote)
            - quote_down_bid: Price to bid for DOWN (None = don't quote)
            - quote_down_ask: Price to ask for DOWN (None = don't quote)
            - quote_size: Size for each quote
            - flatten: True if should flatten all positions (tau <= tau_flatten)
            - reason: String explaining decision
        """
        result = {
            'quote_up_bid': None,
            'quote_up_ask': None,
            'quote_down_bid': None,
            'quote_down_ask': None,
            'quote_size': self.quote_size,
            'flatten': False,
            'reason': 'default',
        }
        
        tau = int(row.get('tau', 0))
        
        # 1. Check flatten condition
        if tau <= self.tau_flatten:
            result['flatten'] = True
            result['reason'] = f'flatten:tau={tau}<={self.tau_flatten}'
            return result
        
        # 2. Check tau window
        if tau < self.tau_min:
            result['reason'] = f'skip:tau={tau}<{self.tau_min}'
            return result
        if tau > self.tau_max:
            result['reason'] = f'skip:tau={tau}>{self.tau_max}'
            return result
        
        # 3. Get prices and spreads
        up_bid = row.get('pm_up_best_bid')
        up_ask = row.get('pm_up_best_ask')
        down_bid = row.get('pm_down_best_bid')
        down_ask = row.get('pm_down_best_ask')
        
        if pd.isna(up_bid) or pd.isna(up_ask) or pd.isna(down_bid) or pd.isna(down_ask):
            result['reason'] = 'skip:missing_prices'
            return result
        
        up_spread = up_ask - up_bid
        down_spread = down_ask - down_bid
        
        # 4. Depth-based filters (if 6-level data available)
        # Track imbalance for later filtering
        imbalance_skip_bid_up = False
        imbalance_skip_ask_up = False
        imbalance_skip_bid_down = False
        imbalance_skip_ask_down = False
        
        if self.imbalance_filter_enabled or self.min_top6_depth > 0:
            # Compute imbalance and depth from 6-level data
            up_imbalance, up_depth = self._compute_imbalance_and_depth(row, 'up')
            down_imbalance, down_depth = self._compute_imbalance_and_depth(row, 'down')
            
            # Book fragility filter: don't quote if depth too thin
            if self.min_top6_depth > 0:
                if up_depth < self.min_top6_depth or down_depth < self.min_top6_depth:
                    result['reason'] = f'skip:thin_book(up_depth={up_depth:.0f},down_depth={down_depth:.0f}<{self.min_top6_depth})'
                    return result
            
            # Imbalance filter: adjust quoting based on book imbalance
            if self.imbalance_filter_enabled and up_imbalance is not None and down_imbalance is not None:
                # If imbalance too large, only quote reducing side or skip
                if abs(up_imbalance) > self.imbalance_threshold:
                    # Positive imbalance = more bids than asks = likely price will rise
                    # In this case, quoting bid is more risky (adverse selection)
                    if up_imbalance > 0:
                        imbalance_skip_bid_up = True
                    else:
                        imbalance_skip_ask_up = True
                
                if abs(down_imbalance) > self.imbalance_threshold:
                    if down_imbalance > 0:
                        imbalance_skip_bid_down = True
                    else:
                        imbalance_skip_ask_down = True
        
        # 5. Check spread minimum OR net-edge threshold
        if self.use_net_edge_threshold:
            # Net edge = expected_spread_capture - expected_AS - buffer
            # expected_spread_capture = 0.5 * spread (for two-sided)
            # expected_AS = expected_as_per_spread * spread
            up_expected_edge = 0.5 * up_spread - self.expected_as_per_spread * up_spread - self.edge_buffer
            down_expected_edge = 0.5 * down_spread - self.expected_as_per_spread * down_spread - self.edge_buffer
            
            up_ok = up_expected_edge >= self.edge_threshold
            down_ok = down_expected_edge >= self.edge_threshold
            
            if not up_ok and not down_ok:
                result['reason'] = f'skip:net_edge_too_low(up={up_expected_edge:.4f},down={down_expected_edge:.4f})'
                return result
        else:
            # Original spread_min check
            if up_spread < self.spread_min and down_spread < self.spread_min:
                result['reason'] = f'skip:spreads_too_tight(up={up_spread:.3f},down={down_spread:.3f})'
                return result
        
        # 5. Adverse selection filter
        if self.adverse_selection_filter and prev_rows is not None and len(prev_rows) > 0:
            # Check for recent CL jump
            cl_mid = row.get('cl_mid')
            if cl_mid is not None and not pd.isna(cl_mid):
                lookback = min(self.cl_lookback_seconds, len(prev_rows))
                if lookback > 0:
                    prev_cl = prev_rows.iloc[-lookback].get('cl_mid')
                    if prev_cl is not None and not pd.isna(prev_cl) and prev_cl > 0:
                        cl_return_bps = abs((cl_mid / prev_cl - 1) * 10000)
                        if cl_return_bps > self.cl_jump_threshold_bps:
                            result['reason'] = f'skip:cl_jump={cl_return_bps:.1f}bps>{self.cl_jump_threshold_bps}'
                            return result
        
        # 6. Inventory limits - don't quote side that would increase position beyond limit
        # Also incorporate imbalance filter restrictions
        can_bid_up = (inventory_up < self.inventory_limit_up) and not imbalance_skip_bid_up
        can_ask_up = (inventory_up > -self.inventory_limit_up) and not imbalance_skip_ask_up  # Short limit
        can_bid_down = (inventory_down < self.inventory_limit_down) and not imbalance_skip_bid_down
        can_ask_down = (inventory_down > -self.inventory_limit_down) and not imbalance_skip_ask_down
        
        # 6b. Inventory skew - only quote side that REDUCES position when imbalanced
        # This is one-sided mode when inventory exceeds skew threshold
        if self.inventory_skew_enabled:
            # UP token skew
            if inventory_up > self.skew_threshold_up:
                # We're long UP, only quote ASK (sell to reduce)
                can_bid_up = False
            elif inventory_up < -self.skew_threshold_up:
                # We're short UP, only quote BID (buy to reduce short)
                can_ask_up = False
            
            # DOWN token skew
            if inventory_down > self.skew_threshold_down:
                # We're long DOWN, only quote ASK (sell to reduce)
                can_bid_down = False
            elif inventory_down < -self.skew_threshold_down:
                # We're short DOWN, only quote BID (buy to reduce short)
                can_ask_down = False
        
        # 8. Calculate quote prices
        tick = 0.01  # Polymarket tick size
        improvement = self.quote_improvement_ticks * tick
        
        # For UP token
        if self.two_sided or self.token == 'UP':
            if up_spread >= self.spread_min:
                # Get price at quote_level (1 = best, 2 = second, etc.)
                if self.quote_level == 1:
                    quote_bid_base = up_bid
                    quote_ask_base = up_ask
                else:
                    quote_bid_base = self._get_quote_price_at_level(row, 'up', 'bid', self.quote_level)
                    quote_ask_base = self._get_quote_price_at_level(row, 'up', 'ask', self.quote_level)
                    # Fallback to L1 if level not available
                    if quote_bid_base is None:
                        quote_bid_base = up_bid
                    if quote_ask_base is None:
                        quote_ask_base = up_ask
                
                if can_bid_up and quote_bid_base is not None:
                    result['quote_up_bid'] = quote_bid_base + improvement  # Join or improve
                if can_ask_up and quote_ask_base is not None:
                    result['quote_up_ask'] = quote_ask_base - improvement  # Join or improve
        
        # For DOWN token
        if self.two_sided or self.token == 'DOWN':
            if down_spread >= self.spread_min:
                # Get price at quote_level
                if self.quote_level == 1:
                    quote_bid_base = down_bid
                    quote_ask_base = down_ask
                else:
                    quote_bid_base = self._get_quote_price_at_level(row, 'down', 'bid', self.quote_level)
                    quote_ask_base = self._get_quote_price_at_level(row, 'down', 'ask', self.quote_level)
                    if quote_bid_base is None:
                        quote_bid_base = down_bid
                    if quote_ask_base is None:
                        quote_ask_base = down_ask
                
                if can_bid_down and quote_bid_base is not None:
                    result['quote_down_bid'] = quote_bid_base + improvement
                if can_ask_down and quote_ask_base is not None:
                    result['quote_down_ask'] = quote_ask_base - improvement
        
        # Build reason string
        quotes = []
        if result['quote_up_bid']: quotes.append(f"bid_up@{result['quote_up_bid']:.2f}")
        if result['quote_up_ask']: quotes.append(f"ask_up@{result['quote_up_ask']:.2f}")
        if result['quote_down_bid']: quotes.append(f"bid_down@{result['quote_down_bid']:.2f}")
        if result['quote_down_ask']: quotes.append(f"ask_down@{result['quote_down_ask']:.2f}")
        
        if quotes:
            result['reason'] = f"quote:{','.join(quotes)}"
        else:
            result['reason'] = 'skip:no_quotes_possible'
        
        return result
    
    def _compute_imbalance_and_depth(
        self,
        row: pd.Series,
        token: str,
    ) -> tuple:
        """
        Compute order book imbalance and total depth from 6-level data.
        
        Args:
            row: Market data row with 6-level columns
            token: 'up' or 'down'
            
        Returns:
            (imbalance, total_depth) where imbalance = (bid_size - ask_size) / (bid_size + ask_size)
            Range: -1 (all asks) to +1 (all bids)
        """
        bid_total = 0.0
        ask_total = 0.0
        
        # Level 1
        bid_col_1 = f'pm_{token}_best_bid_size'
        ask_col_1 = f'pm_{token}_best_ask_size'
        if bid_col_1 in row.index and not pd.isna(row.get(bid_col_1)):
            bid_total += row[bid_col_1]
        if ask_col_1 in row.index and not pd.isna(row.get(ask_col_1)):
            ask_total += row[ask_col_1]
        
        # Levels 2-6
        for level in range(2, 7):
            if level <= self.imbalance_levels or self.min_top6_depth > 0:
                bid_col = f'pm_{token}_bid_{level}_size'
                ask_col = f'pm_{token}_ask_{level}_size'
                if bid_col in row.index and not pd.isna(row.get(bid_col)):
                    bid_total += row[bid_col]
                if ask_col in row.index and not pd.isna(row.get(ask_col)):
                    ask_total += row[ask_col]
        
        total_depth = bid_total + ask_total
        
        if total_depth > 0:
            imbalance = (bid_total - ask_total) / total_depth
        else:
            imbalance = None
        
        return imbalance, total_depth
    
    def _get_quote_price_at_level(
        self,
        row: pd.Series,
        token: str,
        side: str,
        level: int,
    ) -> Optional[float]:
        """
        Get quote price at a specific level.
        
        Args:
            row: Market data row
            token: 'up' or 'down'
            side: 'bid' or 'ask'
            level: 1-6
            
        Returns:
            Price at that level, or None if not available
        """
        if level == 1:
            col = f'pm_{token}_best_{side}'
        else:
            col = f'pm_{token}_{side}_{level}'
        
        if col in row.index:
            price = row.get(col)
            if price is not None and not pd.isna(price):
                return float(price)
        
        return None
    
    def get_flatten_trades(
        self,
        inventory_up: float,
        inventory_down: float,
        row: pd.Series,
    ) -> List[Dict[str, Any]]:
        """
        Generate aggressive trades to flatten inventory before expiry.
        
        Called when tau <= tau_flatten.
        
        Args:
            inventory_up: Current UP position
            inventory_down: Current DOWN position
            row: Current market data
            
        Returns:
            List of trade instructions (taker orders to flatten)
        """
        trades = []
        
        if abs(inventory_up) > 0.01:  # Small tolerance for floating point
            if inventory_up > 0:  # Long UP -> sell
                trades.append({
                    'token': 'UP',
                    'side': 'sell',
                    'size': abs(inventory_up),
                    'price': row.get('pm_up_best_bid'),  # Taker sell at bid
                    'reason': 'flatten_long_up',
                })
            else:  # Short UP -> buy
                trades.append({
                    'token': 'UP',
                    'side': 'buy',
                    'size': abs(inventory_up),
                    'price': row.get('pm_up_best_ask'),  # Taker buy at ask
                    'reason': 'flatten_short_up',
                })
        
        if abs(inventory_down) > 0.01:
            if inventory_down > 0:  # Long DOWN -> sell
                trades.append({
                    'token': 'DOWN',
                    'side': 'sell',
                    'size': abs(inventory_down),
                    'price': row.get('pm_down_best_bid'),
                    'reason': 'flatten_long_down',
                })
            else:  # Short DOWN -> buy
                trades.append({
                    'token': 'DOWN',
                    'side': 'buy',
                    'size': abs(inventory_down),
                    'price': row.get('pm_down_best_ask'),
                    'reason': 'flatten_short_down',
                })
        
        return trades


class SpreadCaptureStrategyV1(SpreadCaptureStrategy):
    """
    Variant A: One-sided quoting with fixed hold time.
    
    Quote one side when spread widens, exit after fixed time or spread compresses.
    Simpler than two-sided, less inventory risk but lower throughput.
    """
    
    def __init__(
        self,
        spread_min: float = 0.02,
        tau_min: int = 120,
        tau_max: int = 600,
        hold_seconds: int = 30,  # Exit after this time
        exit_on_spread_compress: bool = True,  # Exit if spread < spread_min
        **kwargs
    ):
        super().__init__(
            spread_min=spread_min,
            tau_min=tau_min,
            tau_max=tau_max,
            two_sided=False,
            **kwargs
        )
        self.hold_seconds = hold_seconds
        self.exit_on_spread_compress = exit_on_spread_compress
    
    @property
    def name(self) -> str:
        return f"SpreadCaptureV1(hold={self.hold_seconds}s,spread>{self.spread_min:.2f})"


# ==============================================================================
# Strategy Factory
# ==============================================================================

def create_strategy_grid() -> List[Strategy]:
    """
    Create a grid of strategies for parameter sweep.
    
    Returns:
        List of Strategy objects with different parameter combinations
    """
    strategies = []
    
    # Latency capture variations
    for threshold in [5, 10, 15, 20]:
        for hold in [10, 15, 30, 60]:
            strategies.append(LatencyCaptureStrategy(
                threshold_bps=threshold,
                hold_seconds=hold
            ))
    
    # Strike cross variations
    for tau_max in [120, 180, 300, 600]:
        strategies.append(StrikeCrossStrategy(
            tau_max=tau_max,
            hold_to_expiry=True
        ))
        strategies.append(StrikeCrossStrategy(
            tau_max=tau_max,
            hold_to_expiry=False,
            hold_seconds=30
        ))
    
    # Near strike variations
    for near_bps in [10, 20, 30]:
        for min_move in [3, 5, 8]:
            strategies.append(NearStrikeStrategy(
                near_strike_bps=near_bps,
                min_move_bps=min_move,
                hold_seconds=15
            ))
    
    # Momentum variations
    for lookback in [3, 5, 10]:
        for min_move in [10, 15, 20]:
            strategies.append(MomentumStrategy(
                lookback=lookback,
                min_total_move_bps=min_move,
                hold_seconds=15
            ))
    
    return strategies


# ==============================================================================
# Test
# ==============================================================================

if __name__ == '__main__':
    import sys
    from pathlib import Path
    
    project_root = Path(__file__).resolve().parent.parent.parent
    sys.path.insert(0, str(project_root))
    
    from scripts.backtest.data_loader import load_eth_markets, add_derived_columns
    
    print("Loading data...")
    df, market_info = load_eth_markets(min_coverage=90.0)
    df = add_derived_columns(df)
    
    # Test each strategy type
    strategies = [
        LatencyCaptureStrategy(threshold_bps=5, hold_seconds=15),
        StrikeCrossStrategy(tau_max=300),
        MomentumStrategy(lookback=5, min_total_move_bps=10),
        NearStrikeStrategy(near_strike_bps=20, min_move_bps=5),
    ]
    
    print("\nSignal counts by strategy:")
    print("-" * 60)
    
    for strategy in strategies:
        total_signals = 0
        for market_id in df['market_id'].unique():
            market_df = df[df['market_id'] == market_id]
            signals = strategy.generate_signals(market_df)
            total_signals += len(signals)
        
        print(f"{strategy.name}: {total_signals} signals")

